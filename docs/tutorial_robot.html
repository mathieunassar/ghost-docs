<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Create a Simple Robot Simulation · Ghostmodule</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="This tutorial introduces the features &quot;module lifetime&quot;, &quot;observability&quot; and &quot;connection&quot; of the Ghost framework through a practical example: the creation of a robot simulation that provides its position and can be updated with velocity commands."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Create a Simple Robot Simulation · Ghostmodule"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mathieunassar.github.io/ghost-docs/"/><meta property="og:description" content="This tutorial introduces the features &quot;module lifetime&quot;, &quot;observability&quot; and &quot;connection&quot; of the Ghost framework through a practical example: the creation of a robot simulation that provides its position and can be updated with velocity commands."/><meta property="og:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/ghost-docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://mathieunassar.github.io/ghost-docs/blog/atom.xml" title="Ghostmodule Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://mathieunassar.github.io/ghost-docs/blog/feed.xml" title="Ghostmodule Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/ghost-docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/ghost-docs/css/main.css"/><script src="/ghost-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ghost-docs/"><img class="logo" src="/ghost-docs/img/ghost.svg" alt="Ghostmodule"/><h2 class="headerTitleWithLogo">Ghostmodule</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/ghost-docs/docs/ghostmodule" target="_self">Guides</a></li><li class="siteNavGroupActive"><a href="/ghost-docs/docs/tutorial_setup" target="_self">Tutorials</a></li><li class=""><a href="/ghost-docs/help" target="_self">Help</a></li><li class=""><a href="/ghost-docs/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Tutorials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/tutorial_setup">Set Up a New Project Using Ghostmodule</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/ghost-docs/docs/tutorial_robot">Create a Simple Robot Simulation</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Create a Simple Robot Simulation</h1></header><article><div><span><p>This tutorial introduces the features &quot;module lifetime&quot;, &quot;observability&quot; and &quot;connection&quot; of the Ghost framework through a practical example: the creation of a robot simulation that provides its position and can be updated with velocity commands.</p>
<table>
<thead>
<tr><th>Difficulty</th><th>Intermediate</th></tr>
</thead>
<tbody>
<tr><td>Time To Read</td><td>60 minutes</td></tr>
<tr><td>Prerequisites</td><td><a href="/ghost-docs/docs/tutorial_setup">Tutorial: Setup</a>, <a href="/ghost-docs/docs/module">Guide: module</a>, <a href="/ghost-docs/docs/module_observability">Guide: observability</a>, <a href="/ghost-docs/docs/connection">Guide: connection</a></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="summary"></a><a href="#summary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p>A very simplistic robot simulation is created. In this tutorial, we consider an omnidirectional robot that can drive in x and y directions on a plane. The simulation evaluates the position of the robot in its odometry coordinate system based on the robot's velocity.</p>
<p>The created microservice will provide two execution modes:</p>
<ul>
<li>the robot (usage: &quot;connection_grpc_robot robot&quot;), that publishes its pose as a Google Protobuf message of type ghost::examples::protobuf::RobotOdometry;</li>
<li>a subscriber version that receives the odometry messages (usage: &quot;connection_grpc_robot&quot;).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="tutorial"></a><a href="#tutorial" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tutorial</h2>
<h3><a class="anchor" aria-hidden="true" id="step-1-preparation-of-the-project"></a><a href="#step-1-preparation-of-the-project" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 1: Preparation of the Project</h3>
<p>The example program is located in the template repository: <a href="https://github.com/mathieunassar/ghostmodule-template">https://github.com/mathieunassar/ghostmodule-template</a>.</p>
<p>As a first step in this tutorial, we clone the repository and build the example. Please refer to the <a href="/ghost-docs/docs/tutorial_setup">setup tutorial</a> for detailed instructions about how to do that.</p>
<h3><a class="anchor" aria-hidden="true" id="step-2-the-robot-model"></a><a href="#step-2-the-robot-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 2: the Robot Model</h3>
<p>Let's jump into the code! To keep the example minimalist and easy to read, the full program is located in one file: src/connection_grpc_robot.cpp.</p>
<h4><a class="anchor" aria-hidden="true" id="the-main-function"></a><a href="#the-main-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The main function</h4>
<p>In Ghost programs, the main function is responsible for the configuration of the module. We create a ghost::ModuleBuilder, which collects the configured components:</p>
<pre><code class="hljs">auto builder = ghost<span class="hljs-number">::</span>ModuleBuilder<span class="hljs-number">::</span>create()<span class="hljs-comment">;</span>
</code></pre>
<p>In our program, we will need to register custom commands and start connections. These operations belong to the initialization phase of the module, so we register a function to the builder to be called during this phase:</p>
<pre><code class="hljs">builder-&gt;setInitializeBehavior(<span class="hljs-name">std</span>:<span class="hljs-symbol">:bind</span>(<span class="hljs-name">&amp;RobotModule</span>:<span class="hljs-symbol">:initialize</span>, <span class="hljs-symbol">&amp;myModule</span>, std:<span class="hljs-symbol">:placeholders</span>:<span class="hljs-symbol">:_1</span>))<span class="hljs-comment">;</span>
</code></pre>
<p>The class RobotModule will represent the runtime state of the program.</p>
<p>After the initialization, the robot program will cyclically update the robot's pose. We will perform this update in a run() method, which we also register to the builder:</p>
<pre><code class="hljs">builder-&gt;setRunningBehavior(<span class="hljs-name">std</span>:<span class="hljs-symbol">:bind</span>(<span class="hljs-name">&amp;RobotModule</span>:<span class="hljs-symbol">:run</span>, <span class="hljs-symbol">&amp;myModule</span>, std:<span class="hljs-symbol">:placeholders</span>:<span class="hljs-symbol">:_1</span>))<span class="hljs-comment">;</span>
</code></pre>
<p>We will also need access to the console to type commands, a logger to print the odometry to the console, and we will parse the program options to determine whether to start the robot (publisher), or a subscriber of the odometry. This is done by adding these configurations to the builder:</p>
<pre><code class="hljs">auto<span class="hljs-built_in"> console </span>= builder-&gt;setConsole();
builder-&gt;setLogger(ghost::GhostLogger::create(console));
builder-&gt;setProgramOptions(argc, argv);
</code></pre>
<p>Finally, we build the module and run it:</p>
<pre><code class="hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ghost::Module&gt; <span class="hljs-keyword">module</span> = builder-&gt;build(<span class="hljs-string">"ghostRobotExample"</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span>) <span class="hljs-keyword">module</span>-&gt;start();
</code></pre>
<p>At this point the module starts, the initialization method is called, which is followed by cyclic calls to run() until the module is stopped.</p>
<h4><a class="anchor" aria-hidden="true" id="the-initialize-method"></a><a href="#the-initialize-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Initialize method</h4>
<p>We provided an initialize method to the ghost::ModuleBuilder. It expects a function with the following signature:</p>
<p><code>bool initialize(const ghost::Module&amp; module)</code></p>
<p>We therefore declare this function within the class RobotModule:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">initialize</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ghost::Module&amp; <span class="hljs-keyword">module</span>)</span>
</span>{
   _connectionManager = ghost::ConnectionManager::create();
   
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">module</span>.getProgramOptions().hasParameter(<span class="hljs-string">"__0"</span>) &amp;&amp;
     <span class="hljs-keyword">module</span>.getProgramOptions().getParameter&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">"__0"</span>) == <span class="hljs-string">"robot"</span>)
   {
     _robot = <span class="hljs-built_in">std</span>::make_shared&lt;Robot&gt;(_connectionManager, _configuration);
   }
   
   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>In this implementation, we look into the program options to check whether to start the robot or a subscriber. If an unnamed parameter is provided in the first position and its value is &quot;robot&quot;, then we create a robot. We will deal with the connections between the publisher and subscribers in the step 4.</p>
<h4><a class="anchor" aria-hidden="true" id="the-run-method"></a><a href="#the-run-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The run method</h4>
<p>After the module is initialized, we want to keep updating the robot based on a model that modifies its pose based on its velocity. For that, we registered the RobotModule's run() method to the builder. If the module's initialization succeeds, it will be called cyclically until the module is stopped or the function returns false.</p>
<p>This is an implementation of run():</p>
<pre><code class="hljs"><span class="hljs-keyword">bool</span> run(<span class="hljs-keyword">const</span> ghost::Module&amp; module)
{
    <span class="hljs-keyword">if</span> (_robot) _robot-&gt;update();
    <span class="hljs-comment">// The robot will send new odometry data (roughly) with a 2 Hz frequency</span>
    std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">500</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre>
<p>The class Robot is responsible for holding the robot model and therefore exposes an update method:</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> delta = <span class="hljs-built_in">std</span>::chrono::steady_clock::now() - _lastTime;
    <span class="hljs-comment">// Perform very complex operations to compute the super-high-resolution odometry.</span>
    _odoX = _odoX + _velX * <span class="hljs-built_in">std</span>::chrono::duration_cast&lt;<span class="hljs-built_in">std</span>::chrono::milliseconds&gt;(delta).count() / <span class="hljs-number">1000</span>;
    _odoY = _odoY + _velY * <span class="hljs-built_in">std</span>::chrono::duration_cast&lt;<span class="hljs-built_in">std</span>::chrono::milliseconds&gt;(delta).count() / <span class="hljs-number">1000</span>;
    _lastTime += delta;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new pose: x: "</span> &lt;&lt; _odoX &lt;&lt; <span class="hljs-string">" and y: "</span> &lt;&lt; _odoY &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</code></pre>
<p>In this example, the run() function always return true. The only way to stop the module (apart from killing it) is to activate the console (by pressing &quot;enter&quot; so that the prompt is displayed) and type in the &quot;exit&quot; command.</p>
<h3><a class="anchor" aria-hidden="true" id="step-3-a-command-to-update-the-velocity"></a><a href="#step-3-a-command-to-update-the-velocity" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 3: a Command to Update the Velocity</h3>
<p>After step 2, the robot can be started by starting the executable with the &quot;robot&quot; program option. At this point, the robot only drives with a zero velocity, and therefore does not move.</p>
<p>Let's add a console command to set the velocity of the robot, that we can call from the robot program.</p>
<p>In order to create a command, all we need is to create a class deriving from ghost::Command, implement the virtual methods and register it to the module's instance of ghost::CommandLineInterpreter:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateVelocityCommand</span> :</span> <span class="hljs-keyword">public</span> ghost::Command
{
<span class="hljs-keyword">public</span>:
    UpdateVelocityCommand(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Robot&gt;&amp; robot) : _robot(robot)
    {
    }

    <span class="hljs-comment">// The execute method corresponds to the action of this command.</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ghost::CommandLine&amp; commandLine, <span class="hljs-keyword">const</span> ghost::CommandExecutionContext&amp; context)</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">if</span> (!commandLine.hasParameter(<span class="hljs-string">"__0"</span>) || !commandLine.hasParameter(<span class="hljs-string">"__1"</span>) || !_robot) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">double</span> vx = commandLine.getParameter&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">"__0"</span>);
        <span class="hljs-keyword">double</span> vy = commandLine.getParameter&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-string">"__1"</span>);
        _robot-&gt;setVelocity(vx, vy);

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"UpdateVelocityCommand"</span>;
    }
    <span class="hljs-comment">// This method defines the command that he user will have to enter to invoke this command</span>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getShortcut</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"updateVel"</span>;
    }
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Updates the robot's velocity"</span>;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Robot&gt; _robot;
};
</code></pre>
<p>The class is straightforward: the <code>getShortcut()</code> method specify the text that the user must type in the console to trigger the command. The execute method checks that two unnamed parameters are provided as the first and second parameters of the command, and calls <code>setVelocity()</code> on the Robot instance to set the velocity.</p>
<p>In order to register the command, we add the following lines to the initialize method of the RobotModule class:</p>
<pre><code class="hljs">auto <span class="hljs-keyword">command</span> = <span class="hljs-title">std</span>::<span class="hljs-title">make_shared</span>&lt;<span class="hljs-title">UpdateVelocityCommand</span>&gt;(<span class="hljs-title">_robot</span>);
module.getInterpreter()-&gt;registerCommand(<span class="hljs-keyword">command</span>);
</code></pre>
<p>You can now try to execute the program and do the following:</p>
<ul>
<li>activate the console by pressing &quot;enter&quot; so that the prompt is displayed</li>
<li>type &quot;updateVel 1.0 2.0&quot;, so that the robot moves with a velocity of 1 m/s in the x direction and 2 m/s in the y direction.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="step-4-the-odometry-publisher-and-their-subscribers"></a><a href="#step-4-the-odometry-publisher-and-their-subscribers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 4: the Odometry Publisher and their Subscribers</h3>
<p>The final step of this tutorial is to publish the updated pose from the robot program, and to subscribe to this data from the subscriber programs. For this, we use the ghost::ConnectionManager together with Ghost's Google gRPC implementation of the connections.</p>
<h4><a class="anchor" aria-hidden="true" id="initialization-of-the-connections"></a><a href="#initialization-of-the-connections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Initialization of the Connections</h4>
<p>In order to work with connections, we need a ghost::ConnectionManager instance. We also want to use networked connections between the odometry publisher and the subscribers: this can be easily configured by the extension's entry point class ghost::ConnectionGRPC. We therefore add the two lines to the initialization method:</p>
<pre><code class="hljs">_connectionManager = ghost<span class="hljs-number">::</span>ConnectionManager<span class="hljs-number">::</span>create()<span class="hljs-comment">;</span>
ghost<span class="hljs-number">::</span>ConnectionGRP<span class="hljs-number">C::</span>initialize(_connectionManager)<span class="hljs-comment">;</span>
</code></pre>
<p>The second line adds rules to the connection manager's factory that link all connection configurations of the type ghost::ConnectionConfigurationGRPC to implementations using google gRPC.</p>
<p>We also define that the publisher will be reachable on the localhost on the port 8562:</p>
<pre><code class="hljs"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_configuration</span>.</span></span>set<span class="hljs-constructor">ServerIpAddress(<span class="hljs-string">"127.0.0.1"</span>)</span>;
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_configuration</span>.</span></span>set<span class="hljs-constructor">ServerPortNumber(8562)</span>;
</code></pre>
<p>Based on the connection manager and this configuration, we can create the publisher in the constructor of the Robot class:</p>
<pre><code class="hljs">auto publisher = connectionManager-&gt;createPublisher(config);
if (publisher-&gt;start())
    _odometryWriter = publisher-&gt;getWriter&lt;ghost::examples::protobuf::RobotOdometry&gt;();
</code></pre>
<p>The last line gets a ghost::Writer object that is used to push messages of type ghost::examples::protobuf::RobotOdometry to the publisher.</p>
<p>We can continue with creating the subscriber:</p>
<pre><code class="hljs">auto subscriber = _connectionManager-&gt;createSubscriber(_configuration);

auto messageHandler = subscriber-&gt;addMessageHandler();
messageHandler-&gt;addHandler&lt;ghost::examples::protobuf::RobotOdometry&gt;(&amp;odmetryMessageHandler);
</code></pre>
<p>and start it:</p>
<pre><code class="hljs"><span class="hljs-keyword">bool </span><span class="hljs-keyword">subscriberStartResult </span>= <span class="hljs-keyword">subscriber-&gt;start();
</span><span class="hljs-symbol">if</span> (!<span class="hljs-keyword">subscriberStartResult)
</span>{
    GHOST_ERROR(module.getLogger()) &lt;&lt; <span class="hljs-string">"Couldn't find the robot! Start this program with the \"robot\" option."</span><span class="hljs-comment">;</span>
}
</code></pre>
<p>You may have noticed that we added a message handler to the subscriber. We also added a handler for messages of the odometry type. The handler &quot;odometryMessageHandler&quot; is a function that processes incoming messages. In our example, we will simply print it:</p>
<pre><code class="hljs"><span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">odmetryMessageHandler</span>(<span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">ghost</span><span class="hljs-selector-pseudo">::examples</span><span class="hljs-selector-pseudo">::protobuf</span><span class="hljs-selector-pseudo">::RobotOdometry</span>&amp; <span class="hljs-selector-tag">message</span>)
{
    <span class="hljs-attribute">std</span>::cout &lt;&lt; <span class="hljs-string">"Received odometry: "</span> &lt;&lt; message.<span class="hljs-built_in">x</span>() &lt;&lt; <span class="hljs-string">"; "</span> &lt;&lt; message.<span class="hljs-built_in">y</span>() &lt;&lt; <span class="hljs-string">" [m/s; m/s]"</span> &lt;&lt; std::endl;
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="publish-the-odometry"></a><a href="#publish-the-odometry" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Publish the Odometry</h4>
<p>The last piece of the connection puzzle is... to actually send the odometry. Since we created a ghost::Writer from the publisher in the Robot class, we can simply use it and extend the Robot's update() method with the sending part:</p>
<pre><code class="hljs">auto msg = ghost::examples::protobuf::RobotOdometry::default_instance();
msg.set_x(_odoX);
msg.set_y(_odoY);

_odometryWriter-&gt;write(msg);
</code></pre>
<p>You can now compile the program again and start a &quot;robot&quot; instance, followed by multiple subscriber instances (simply start the program without options). If everything worked well, the subscribers should all receive odometry messages twice per second! You can also test the &quot;updateVel&quot; command by setting a new velocity. Once you do that, the subscribers should start receiving updated poses based on the new velocity.</p>
<p><strong>Congratulations! You successfully created your first Ghost microservice!</strong> You can now spend some time to investigate the rest of the features and start building your own programs with the Ghost framework.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/ghost-docs/docs/tutorial_setup"><span class="arrow-prev">← </span><span>Set Up a New Project Using Ghostmodule</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#summary">Summary</a></li><li><a href="#tutorial">Tutorial</a><ul class="toc-headings"><li><a href="#step-1-preparation-of-the-project">Step 1: Preparation of the Project</a></li><li><a href="#step-2-the-robot-model">Step 2: the Robot Model</a></li><li><a href="#step-3-a-command-to-update-the-velocity">Step 3: a Command to Update the Velocity</a></li><li><a href="#step-4-the-odometry-publisher-and-their-subscribers">Step 4: the Odometry Publisher and their Subscribers</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/ghost-docs/" class="nav-home"><img src="/ghost-docs/img/ghost.svg" alt="Ghostmodule" width="66" height="58"/></a><div><h5>Docs</h5><a href="/ghost-docs/docs/en/setup">Getting Started</a><a href="/ghost-docs/docs/en/module">Guides</a><a href="/ghost-docs/docs/en/tutorial_helloworld">Tutorials</a></div><div><h5>Community</h5><a href="/ghost-docs/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/ghost-docs/blog">Blog</a><a href="https://github.com/mathieunassar">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/mathieunassar/ghostmodule/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/ghost-docs/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Mathieu Nassar</section></footer></div></body></html>