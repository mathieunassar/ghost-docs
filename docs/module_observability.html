<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Module: Observability · GhostDocs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In this guide, the built-in features of ghostmodule that enable microservice observability are described. The ability to observe the state of a microservice, and possibly interact with it, is an important functionality that can serve multiple purposes such as monitoring, debugging, commissioning or manual operation."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Module: Observability · GhostDocs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mathieunassar.github.io/ghost-docs/"/><meta property="og:description" content="In this guide, the built-in features of ghostmodule that enable microservice observability are described. The ability to observe the state of a microservice, and possibly interact with it, is an important functionality that can serve multiple purposes such as monitoring, debugging, commissioning or manual operation."/><meta property="og:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/ghost-docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://mathieunassar.github.io/ghost-docs/blog/atom.xml" title="GhostDocs Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://mathieunassar.github.io/ghost-docs/blog/feed.xml" title="GhostDocs Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/ghost-docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/ghost-docs/css/main.css"/><script src="/ghost-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ghost-docs/"><img class="logo" src="/ghost-docs/img/ghost.svg" alt="GhostDocs"/><h2 class="headerTitleWithLogo">GhostDocs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/ghost-docs/docs/module" target="_self">Guides</a></li><li class=""><a href="/ghost-docs/docs/tutorial_helloworld" target="_self">Tutorials</a></li><li class=""><a href="/ghost-docs/help" target="_self">Help</a></li><li class=""><a href="/ghost-docs/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Library Guides</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/setup">Set Up a New Project Using Ghostmodule</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/installation">Build Ghostmodule from Source</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Library Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module">Module: Microservice Framework</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/ghost-docs/docs/module_observability">Module: Observability</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module_threading">Module: Threading</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection">Connection: Exchange Data Between Your Programs</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection_extensions">Connection: Develop New Extensions</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/persistence">Persistence: Store Your Program&#x27;s Data</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Developer Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection_grpc">Connection: a gRPC async Implementation</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Module: Observability</h1></header><article><div><span><p>In this guide, the built-in features of ghostmodule that enable microservice observability are described. The ability to observe the state of a microservice, and possibly interact with it, is an important functionality that can serve multiple purposes such as monitoring, debugging, commissioning or manual operation.</p>
<p>The Ghost framework provides the following components to observe microservices:</p>
<ul>
<li>A Logger interface (ghost::Logger);</li>
<li>the console utility (ghost::Console);</li>
<li>the command line interpreter (ghost::CommandLineInterpreter);</li>
<li>a user manager including session management (ghost::UserManager).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="logging-interface"></a><a href="#logging-interface" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Logging Interface</h2>
<h3><a class="anchor" aria-hidden="true" id="feature-description"></a><a href="#feature-description" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>A very simple interface logging interface can be set via the ghost::MobuleBuilder during the configuration phase of the microservice. The interface provides five methods to log information at different levels:</p>
<ul>
<li><code>error()</code>: feed an error description to the underlying system;</li>
<li><code>warn()</code>: use this method to indicate that unexpected activity is happening, but no error has occurred yet</li>
<li><code>info()</code>: prints information about the current operations in the microservice</li>
<li><code>debug()</code>: writes information that helps analyzing issues and bugs</li>
<li><code>trace()</code>: most granular type of information, that may also be logged cyclically</li>
</ul>
<p>The actual implementation is also determined during the configuration phase. ghostmodule exposes two implementations of simple loggers:</p>
<ul>
<li>ghost::StdoutLogger: simply prints the content with std::cout with a prefix depending on the information level;</li>
<li>ghost::GhostLogger: also prints the content to the console, but using the ghost::Console utility, which is described in the next section.</li>
</ul>
<p>In order to develop specific or more extensive implementations of the ghost::Logger, Users are required to inherit from the interface and implement the corresponding virtual methods.</p>
<h3><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>The logger is accessible from the ghost::Module entry point class. In order to write log lines, a few C++ defines exist to make the calls more recognizable and readable. Writing an info log line is done the following way:</p>
<p><code>GHOST_INFO(module-&gt;getLogger()) &lt;&lt; &quot;This is a log line in &quot; &lt;&lt; 2020;</code></p>
<p>Writing trace, debug, warn and error logs are achieved by replacing the &quot;INFO&quot; letters by the respective matching capital letters.</p>
<h2><a class="anchor" aria-hidden="true" id="console-utility"></a><a href="#console-utility" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Console Utility</h2>
<h3><a class="anchor" aria-hidden="true" id="feature-description-1"></a><a href="#feature-description-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>The console utility solves the following problem: how to display log information and expect user input at the same time? The solution implemented by ghost::Console is the following.</p>
<p>The module framework has two console states: Input and Output. While the state is Output, the microservice prints log information. On the contrary, during the Input state, the console saves the output log lines while it expects the User to provide some input. Once the User is finished providing input, the saved log lines are displayed and logging is resumed.</p>
<p>In order to switch from Output to Input, it is simply necessary to press the &quot;Enter&quot; key. A prompt string is then displayed to indicate that the mode is now Input.</p>
<h4><a class="anchor" aria-hidden="true" id="activating-the-console"></a><a href="#activating-the-console" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Activating the Console</h4>
<p>Pressing Output again will have the following effect:</p>
<ul>
<li>if nothing has been written in the Input mode, then the mode is switched to Output;</li>
<li>if something has been written in the Input mode, then a command is submitted to the module, and:
<ul>
<li>per default, the mode is switched to Output;</li>
<li>if configured, another command is expected by the user.</li>
</ul></li>
</ul>
<p>The following two pictures illustrate an example module in which the mode is Input (top), and in which it is Output (bottom)</p>
<p><img src="/ghost-docs/docs/assets/ghostmodule_console_input.png" alt="Diagram: ghostmodule and Extensions"></p>
<p><img src="/ghost-docs/docs/assets/ghostmodule_console_output.png" alt="Diagram: ghostmodule and Extensions"></p>
<h4><a class="anchor" aria-hidden="true" id="input-modes"></a><a href="#input-modes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Input Modes</h4>
<p>During the configuration phase of the microservice, it is possible to set the ghost::InputMode of the console to the following values:</p>
<ul>
<li>SEQUENTIAL: once the Input mode is activated, it will only be deactivated by pressing the &quot;Enter&quot; key without writing a command. As a result, Users do not need to switch to the Input mode again in order to provide a sequence of commands.</li>
<li>DISCRETE: <strong>(Default)</strong> after a command is provided, the console mode is automatically switched back to Output. Hence, in order to write multiple commands, it is necessary to activate the Input mode before each command.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="usage-1"></a><a href="#usage-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>If this functionality is necessary in a project, the console must be explicitly activated during the configuration phase of the microservice. For this purpose, the ghost::ModuleBuilder provides the <code>setConsole()</code> method. This call sets up a ghost::Console object and returns it, so that it can be configured.</p>
<p><em>Note: at this point, the console is not active: it will be started during the initialization phase of the ghost::Module. Users may however start the console earlier by calling <code>start()</code> on the retrieved console object.</em></p>
<p>During the configuration of the console, the following parameters can be configured:</p>
<ul>
<li>the ghost::InputMode, as mentioned above;</li>
<li>the format of the prompt, that is displayed when the Input mode is activated</li>
<li>a callback to call when a new command is provided (per default, the ghost::Module registers a callback to links the user input to the ghost::CommandLineInterpreter)</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="command-line-interpretation"></a><a href="#command-line-interpretation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Command Line Interpretation</h2>
<h3><a class="anchor" aria-hidden="true" id="feature-description-2"></a><a href="#feature-description-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>One possible usage of the console is to interpret user input as command lines and execute them. The default routing of a ghost::Console in a ghost::Module forwards the lines entered by the User to the module's instance of ghost::CommandLineInterpreter. It effectively calls the interpreter's method <code>execute()</code> with a line that is provided by the ghost::Console callback mechanism.</p>
<p>Prior to the execution phase, it is possible to configure the interpreter with custom commands by calling the interpreter's method <code>registerCommand()</code>. While registering new commands, it is also possible to restrict their access to a specific set of registered users: this feature is introduced in the next section.</p>
<p>A few commands are pre-loaded in the interpreter:</p>
<ul>
<li>exit: stops the module, triggering a graceful shutdown of its components (the module switches to the Disposal phase);</li>
<li>help: displays a list of available commands including a description string;</li>
<li>login: requests a username and a password from the User and attempts to log them into the user manager.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="usage-2"></a><a href="#usage-2" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>Commands are represented by instances of classes realizing the ghost::Command interface, illustrated hereunder. It provides the interpreter with several information which are used to document the commands, as well as the <code>execute()</code> method that is called by the interpreter once a matching command is received and parsed.</p>
<p><img src="/ghost-docs/docs/assets/ghostmodule_command.png" alt="Diagram: ghostmodule and Extensions"></p>
<p>The shortcut field represents the string that identifies the command and needs to by typed by the user to activate it. The name, description and category strings are used by the &quot;help&quot; command to sort and list the available commands. Finally, the required and optional parameters lists are used to generate a usage string (for documentation purpose). Additionally, those two lists serve as preconditions for the execution of the commands. A missing required parameter prevents the execution of the command.</p>
<h2><a class="anchor" aria-hidden="true" id="user-permissions-management"></a><a href="#user-permissions-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>User Permissions Management</h2>
<h3><a class="anchor" aria-hidden="true" id="feature-description-3"></a><a href="#feature-description-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>In some situations it is preferrable to restrict the access of some commands to some priviledged users, such as experienced operators.</p>
<h4><a class="anchor" aria-hidden="true" id="users-and-groups"></a><a href="#users-and-groups" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Users and Groups</h4>
<p>The ghost::UserManager component allows microservice developers to create users and groups of users, so-called &quot;permission entities&quot;, ghost::PermissionEntity). The user manager can then be used in combination with the command interpreter to set up permissions to the commands. This happens during calls to the interpreter's <code>registerCommand()</code> method.</p>
<p>Similarly to a *nix system, users may belong to groups. This affects in particular the command line interpreter: restricting a command to a user group allows every user of this group to execute the command.</p>
<h4><a class="anchor" aria-hidden="true" id="user-session-and-login-system"></a><a href="#user-session-and-login-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>User Session and Login System</h4>
<p>When a user executes a command, the <code>execute()</code> method of the ghost::Command is called with an object of type ghost::CommandExecutionContext. The context contains the ghost::Console that triggered the execution (it can be used to read and write lines), and a ghost::Session object that can be used to keep track of the user.</p>
<p>In order to execute user-restricted commands, a user of the microservice must first login into the user manager, with a login and a password that has been predefined by the developers of the application. The <code>connect()</code> method of the ghost::UserManager expects a ghost::Session object, which will be associated with the user who just connected. The same session will be re-used for every call made by the same ghost::Console object and can therefore be used as a key to associate data to a specific session.</p>
<h3><a class="anchor" aria-hidden="true" id="usage-3"></a><a href="#usage-3" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>The ghost::UserManager can be first accessed during the initialization phase of the ghost::Module (after it has been built with a ghost::ModuleBuilder). During this phase, users and groups can be added by calling the methods <code>createUser()</code>, <code>createUserGroup()</code> and <code>addUserToGroup()</code>.</p>
<p><em>Note: A default user is added with username &quot;superuser&quot; and password &quot;superuser&quot;.</em></p>
<p>Per default, a login command is registered in the command interpreter. This command requests a username and a password from the console and attempts to connect the user to the ghost::UserManager.</p>
<p><em>Note: commands can be overridden by registering a new command with the same shortcut (the return value of ghost::Command::getShortcut is identical).</em></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/ghost-docs/docs/module"><span class="arrow-prev">← </span><span>Module: Microservice Framework</span></a><a class="docs-next button" href="/ghost-docs/docs/module_threading"><span>Module: Threading</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#logging-interface">Logging Interface</a><ul class="toc-headings"><li><a href="#feature-description">Feature Description</a></li><li><a href="#usage">Usage</a></li></ul></li><li><a href="#console-utility">Console Utility</a><ul class="toc-headings"><li><a href="#feature-description-1">Feature Description</a></li><li><a href="#usage-1">Usage</a></li></ul></li><li><a href="#command-line-interpretation">Command Line Interpretation</a><ul class="toc-headings"><li><a href="#feature-description-2">Feature Description</a></li><li><a href="#usage-2">Usage</a></li></ul></li><li><a href="#user-permissions-management">User Permissions Management</a><ul class="toc-headings"><li><a href="#feature-description-3">Feature Description</a></li><li><a href="#usage-3">Usage</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/ghost-docs/" class="nav-home"><img src="/ghost-docs/img/ghost.svg" alt="GhostDocs" width="66" height="58"/></a><div><h5>Docs</h5><a href="/ghost-docs/docs/en/setup">Getting Started</a><a href="/ghost-docs/docs/en/module">Guides</a><a href="/ghost-docs/docs/en/tutorial_helloworld">Tutorials</a></div><div><h5>Community</h5><a href="/ghost-docs/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/ghost-docs/blog">Blog</a><a href="https://github.com/mathieunassar">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/mathieunassar/ghostmodule/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/ghost-docs/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Mathieu Nassar</section></footer></div></body></html>