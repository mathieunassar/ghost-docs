<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Module: Threading · GhostDocs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The Ghost framework is designed to enable single-threaded applications as well as programs with task parallelization potential."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Module: Threading · GhostDocs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mathieunassar.github.io/ghost-docs/"/><meta property="og:description" content="The Ghost framework is designed to enable single-threaded applications as well as programs with task parallelization potential."/><meta property="og:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/ghost-docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://mathieunassar.github.io/ghost-docs/blog/atom.xml" title="GhostDocs Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://mathieunassar.github.io/ghost-docs/blog/feed.xml" title="GhostDocs Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/ghost-docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/ghost-docs/css/main.css"/><script src="/ghost-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ghost-docs/"><img class="logo" src="/ghost-docs/img/ghost.svg" alt="GhostDocs"/><h2 class="headerTitleWithLogo">GhostDocs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/ghost-docs/docs/module" target="_self">Guides</a></li><li class=""><a href="/ghost-docs/docs/tutorial_helloworld" target="_self">Tutorials</a></li><li class=""><a href="/ghost-docs/help" target="_self">Help</a></li><li class=""><a href="/ghost-docs/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Library Guides</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/setup">Set Up a New Project Using Ghostmodule</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/installation">Build Ghostmodule from Source</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Library Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module">Module: Microservice Framework</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module_observability">Module: Observability</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/ghost-docs/docs/module_threading">Module: Threading</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection">Connection: Exchange Data Between Your Programs</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection_extensions">Connection: Develop New Extensions</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/persistence">Persistence: Store Data to the Disk</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Developer Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection_grpc">Connection: a gRPC async Implementation</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Module: Threading</h1></header><article><div><span><p>The Ghost framework is designed to enable single-threaded applications as well as programs with task parallelization potential.</p>
<h3><a class="anchor" aria-hidden="true" id="feature-description"></a><a href="#feature-description" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>The main actor of the threading concept is the class ghost::ThreadPool, exposed by the library ghostmodule. Instances of this class are created and managed by the ghost::Module instance itself. Like its name suggests, the thread pool runs a number of threads that are dedicated to the execution of diverse tasks in the module.</p>
<h5><a class="anchor" aria-hidden="true" id="scheduling-single-tasks"></a><a href="#scheduling-single-tasks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scheduling Single Tasks</h5>
<p>The most basic functionality of the thread pool is to accept tasks from the User and execute them. Tasks are provided as a template parameter to ghost::ThreadPool's <code>execute()</code> method that must be a callable type: an std::function, a lambda, or the result of a call to std::bind. The <code>execute()</code> method returns an std::future object that contains the return value of the task. Once accepted, the task is enqueued for execution and available threads in the pool will take care of it.</p>
<p><em>Note: the thread pool only executes tasks once started (by either calling <code>start()</code> or by starting the ghost::Module that manages the pool).</em></p>
<h5><a class="anchor" aria-hidden="true" id="scheduling-with-fixed-rate"></a><a href="#scheduling-with-fixed-rate" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scheduling With Fixed Rate</h5>
<p>A common use-case for microservices is to check the state of a variable or any other entity and act. While a dedicated thread could be allocated to that task and wait for a state change, in most cases it is more resource-efficient to schedule this check with a fixed rate. By doing so, a single thread could take care of several similar tasks, hence saving thread resources to the program and increasing its performance and scalability.</p>
<p>The ghost::ThreadPool exposes for this purpose the class ghost::ScheduledExecutor, which can be constructed from a call to ghost::ThreadPool's <code>makeScheduledExecutor()</code> method. Analogously to its Java counterpart, ghost::ScheduledExecutor provides a method called <code>scheduleAtFixedRate()</code>, that expects a task and a desired execution rate. This method has the following restrictions:</p>
<ul>
<li>the tasks may not return a value (its return type must be void);</li>
<li>if the task takes longer to execute than the commanded execution rate, then the next task is delayed: the task is not executed concurrently.</li>
</ul>
<h5><a class="anchor" aria-hidden="true" id="lifetime"></a><a href="#lifetime" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lifetime</h5>
<p>ghost::ThreadPool objects are always owned by a ghost::Module instance. Although they possess a <code>start()</code> and a <code>stop()</code> method, it is not necessary to call them: the lifetime of the thread pools follows that of the module.</p>
<p>At the beginning of the initialization phase, the module calls <code>start()</code> on all the thread pools that have been added at the configuration phase. This ensures that the pools are ready to execute tasks before the user-provided initialization behavior is called.</p>
<p>At the end of the disposal phase, the module calls their <code>stop()</code> method. Stopping the pools is the last operation done by the module before it ends, because user code and ghost::ModuleExtensions may be relying on the thread pool to finish their operation. The disposal behavior is therefore the best time to stop and finalize the components, so that no dead locks / starvation situation occur.</p>
<p><em>Important note: all the tasks that are operating on class members must complete before the destructor of the corresponding classes is called. Otherwise segmentation faults may occur! For this purpose, please always stop executors and await the completion of open tasks before the destructor ends by either calling the <code>stop()</code> method of the executors or by waiting for the std::future that is returned by the pool's <code>execute()</code> method.</em></p>
<p>The following sequence diagram illustrates the typical runtime of a module. On the right side, a &quot;User class&quot; makes use of the ghost::ThreadPool to create a scheduled executor to perform periodic calls [2]. Note that the &quot;user class&quot; calls <code>stop()</code> [5] on the ghost::ScheduledExecutor before the module exits (the green arrow).</p>
<p><img src="/ghost-docs/docs/assets/ghostmodule_threadpool_lifetime.png" alt="Diagram: ghostmodule and Extensions"></p>
<h5><a class="anchor" aria-hidden="true" id="yielding-the-execution"></a><a href="#yielding-the-execution" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Yielding the Execution</h5>
<p>It may happen that an implementation needs to wait for the completion of another task before continuing its execution. In these cases, the options are usually to use a condition variable and pause the thread's execution, or to have a sleep behavior that also blocks the thread. The threading concept of the Ghost framework brings a third option, which is offered by ghost::ThreadPool's <code>yield()</code> method: calling this method will execute jobs enqueued in the thread pool for at least the provided duration instead of wasting CPU time waiting.</p>
<h5><a class="anchor" aria-hidden="true" id="single-threaded-programs"></a><a href="#single-threaded-programs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single-Threaded Programs</h5>
<p>It is possible to use the ghost::ThreadPool in a single-threaded program. To achieve this configuration, it is simply necessary to call the pool's <code>resize()</code> method with a size of zero. In this case, no threads will be started, and the only worker available is the ghost::Module itself. In this use-case, the enqueued tasks are executed sequentially by the main thread.</p>
<p><em>Note: blocking a thread with a single-threaded configuration obviously causes the whole program to block. Therefore it is always recommended to yield execution with ghost::ThreadPool's <code>yield()</code> method instead of sleeping.</em></p>
<h3><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>Every ghost::Module possesses at least one thread pool which is created by default. The configuration of existing thread pools or adding new thread pools can be done at any stage of the lifetime of the module. Existing thread pools are automatically started at the beginning of the initialization phase of the module (prior to the execution of the configured initialization behavior). Thread pools created after this phase must be manually started by calling their <code>start()</code> method.</p>
<p>In order to create a new thread pool, the ghost::ModuleBuilder and ghost::Module expose the method <code>addThreadPool()</code>, which expects a name used to retrieve the pool and the pool's target size.</p>
<p>In order to retrieve an existing thread pool from the module, both ghost::ModuleBuilder and ghost::Module provide a <code>getThreadPool()</code> method that expects the name of the pool to retrieve. Providing an empty string (which is the default parameter) returns the default thread pool, which is used to execute the module's running behavior and the built-in routines (e.g. the console tasks).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/ghost-docs/docs/module_observability"><span class="arrow-prev">← </span><span>Module: Observability</span></a><a class="docs-next button" href="/ghost-docs/docs/connection"><span>Connection: Exchange Data Between Your Programs</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/ghost-docs/" class="nav-home"><img src="/ghost-docs/img/ghost.svg" alt="GhostDocs" width="66" height="58"/></a><div><h5>Docs</h5><a href="/ghost-docs/docs/en/setup">Getting Started</a><a href="/ghost-docs/docs/en/module">Guides</a><a href="/ghost-docs/docs/en/tutorial_helloworld">Tutorials</a></div><div><h5>Community</h5><a href="/ghost-docs/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/ghost-docs/blog">Blog</a><a href="https://github.com/mathieunassar">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/mathieunassar/ghostmodule/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/ghost-docs/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Mathieu Nassar</section></footer></div></body></html>