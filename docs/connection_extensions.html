<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Connection: Develop New Extensions · Ghostmodule</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="As described by the ghost_connection guide ([Read it here](/ghost-docs/docs/connection)), the library exposes a generic communication structure. In order to use it, Users must provide an implementation of the ghost::Connection interfaces that matches their requirements. The implementation depends on the technology needed and could be as diverse as a local program communication or a networked connection over a MQTT system. The ghost framework provides a ready-to-use extension based on Google gRPC."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Connection: Develop New Extensions · Ghostmodule"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mathieunassar.github.io/ghost-docs/"/><meta property="og:description" content="As described by the ghost_connection guide ([Read it here](/ghost-docs/docs/connection)), the library exposes a generic communication structure. In order to use it, Users must provide an implementation of the ghost::Connection interfaces that matches their requirements. The implementation depends on the technology needed and could be as diverse as a local program communication or a networked connection over a MQTT system. The ghost framework provides a ready-to-use extension based on Google gRPC."/><meta property="og:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://mathieunassar.github.io/ghost-docs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/ghost-docs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://mathieunassar.github.io/ghost-docs/blog/atom.xml" title="Ghostmodule Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://mathieunassar.github.io/ghost-docs/blog/feed.xml" title="Ghostmodule Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/ghost-docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/ghost-docs/css/main.css"/><script src="/ghost-docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ghost-docs/"><img class="logo" src="/ghost-docs/img/ghost.svg" alt="Ghostmodule"/><h2 class="headerTitleWithLogo">Ghostmodule</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/ghost-docs/docs/ghostmodule" target="_self">Guides</a></li><li class=""><a href="/ghost-docs/docs/tutorial_setup" target="_self">Tutorials</a></li><li class=""><a href="/ghost-docs/help" target="_self">Help</a></li><li class=""><a href="/ghost-docs/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Library Guides</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/ghostmodule">Ghostmodule</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Library Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module">Module: Microservice Framework</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module_observability">Module: Observability</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/module_threading">Module: Threading</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection">Connection: Exchange Data Between Your Programs</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/ghost-docs/docs/connection_extensions">Connection: Develop New Extensions</a></li><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/persistence">Persistence: Store Your Program&#x27;s Data</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Developer Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/ghost-docs/docs/connection_grpc">Connection: a gRPC async Implementation</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Connection: Develop New Extensions</h1></header><article><div><span><p>As described by the ghost_connection guide (<a href="/ghost-docs/docs/connection">Read it here</a>), the library exposes a generic communication structure. In order to use it, Users must provide an implementation of the ghost::Connection interfaces that matches their requirements. The implementation depends on the technology needed and could be as diverse as a local program communication or a networked connection over a MQTT system. The ghost framework provides a ready-to-use extension based on Google gRPC.</p>
<p>In this guide, the following two points are explained:</p>
<ul>
<li>The mechanisms of the ghost::ConnectionFactory, responsible for the creation of the connections;</li>
<li>The message pipeline of a connection and how to use it.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="providing-connection-technologies-to-ghost_connection-ghostconnectionfactory"></a><a href="#providing-connection-technologies-to-ghost_connection-ghostconnectionfactory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Providing Connection Technologies to ghost_connection: ghost::ConnectionFactory</h2>
<h3><a class="anchor" aria-hidden="true" id="feature-description"></a><a href="#feature-description" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>The ghost::ConnectionManager creates ghost::Connection objects with the help of the ghost::ConnectionFactory, whose responsibility is to create connection objects with the correct underlying implementation. The factory possesses rules which associate a templated type to a configuration model. When a connection configuration is provided to the connection manager, the corresponding factory rule is searched. If all the fields of the rule's configuration model are defined in the provided user configuration, then the factory rule is selected to build the ghost::Connection.</p>
<p>Integrating new communication technologies into ghost_connection therefore consists in the following steps:</p>
<ul>
<li>define a minimum configuration that all requests to the ghost::ConnectionManager must fulfill in order to use the new implementation;</li>
<li>Register the classes implementing the ghost::Connection interfaces to the ghost::ConnectionFactory.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>The ghost::ConnectionFactory is available as soon as the ghost::ConnectionExtensionBuilder is created by retrieving the ghost::ConnectionManger from the builder and calling its <code>getConnectionFactory()</code> method. The factory can be extended at any time after this point.</p>
<p>In order to register new factory rules, the ghost::ConnectionFactory exposes four template methods: <code>addServerRule()</code>, <code>addClientRule()</code>, <code>addPublisherRule()</code>, <code>addSubscriberRule()</code>. The template parameter of the method must be the implementation class realizing the ghost::Connection interfaces (e.g. <code>addServerRule()</code> accepts a template parameter that realizes the interface ghost::Server).</p>
<p>For example, the Ghost library ghost_connection_grpc provides an implementation of the four connection types using Google gRPC. The library also defines a specific configuration class named ghost::ConnectionConfigurationGRPC, which is registered as the minimum configuration necessary to create connections using this implementation (This registration is done by the class ghost::ConnectionGRPC).</p>
<h2><a class="anchor" aria-hidden="true" id="developing-a-new-connection-technology"></a><a href="#developing-a-new-connection-technology" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Developing a New Connection Technology</h2>
<h3><a class="anchor" aria-hidden="true" id="feature-description-1"></a><a href="#feature-description-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Feature Description</h3>
<p>Each connection type exposed by ghost_connection extends the ghost::Connection interface which provides methods for the lifetime of connections, but also a reader or writer interface, as described in the (<a href="/ghost-docs/docs/connection">ghost_connection guide</a>). ghost::ReadableConnection and ghost::WritableConnection expose both the consumer side (e.g. a <code>write()</code> method on a publisher to send messages to subscribers) and the producer side of the connection (e.g. a method to push received messages into the connection object for a subscriber).</p>
<p>The producer side of readable connections is represented by a ghost::ReaderSink. This class exposes a <code>put()</code> method that must be used in order to provide received messages to a ghost::Client or ghost::Subscriber. If users of the connection registered a ghost::MessageHandler, calling <code>put()</code> will directly pass the message to the User's handler method. The return value of the <code>put()</code> method can be used to determine whether the connection has been closed or not.</p>
<p>A similar feature exist for writable connections. ghost::WriterSink exposes a <code>get()</code> method that provides a message if Users of the connection called <code>write()</code> on an ghost::Writer associated to this connection. A timeout may be configured in order to parameterize the blocking/non-blocking behavior of the implementation. Once the message is processed (e.g. sent through the implemented communication technology), the message must be removed by calling the sink's <code>pop()</code> method.</p>
<p>Both ghost::ReaderSink and ghost::WriterSink are accessible through protected methods of the ghost::ReadableConnection, resp. ghost::WritableConnection. The sinks are therefore available to the implementation, but not to the Users of the connection interfaces.</p>
<p>The following diagram illustrates the data flow in the class hierarchy of publishers and subscribers. The classes in blue represent the implementation of the actual communication. The sinks are made available to the implementation, while the user is able to create writer/reader objects.</p>
<p><img src="/ghost-docs/docs/assets/ghostconnection_sinks.png" alt="Diagram: ghostmodule and Extensions"></p>
<h3><a class="anchor" aria-hidden="true" id="usage-1"></a><a href="#usage-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>Developing a new connection technology therefore consists in creating an implementation for the connection interfaces ghost::Publisher, ghost::Subscriber, ghost::Server and ghost::Client. In particular the implementation is responsible for the following:</p>
<ul>
<li>open a communication channel between a ghost::Server and a ghost::Client, or between a ghost::Publisher and a ghost::Subscriber;</li>
<li>for ghost::Publisher and ghost::Client (implementing ghost::WritableConnection): get messages from user calls through the sink's <code>get()</code> method and actually send the messages;</li>
<li>for ghost::Subscriber and ghost::Client (implementing ghost::ReadableConnection): read messages from the communication channel and push the results through the sink's <code>put()</code> method;</li>
<li>manage the lifetime of the connection by defining and implementing a starting and stopping behavior.</li>
</ul>
<p><em>Note: you can analyze the implementation of the ghost_connection_grpc library as an example of this guide. The library integrates Google gRPC to send the messages available in ghost::WriterSink objects and put received messages into ghost::ReaderSink objects.</em></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/ghost-docs/docs/connection"><span class="arrow-prev">← </span><span>Connection: Exchange Data Between Your Programs</span></a><a class="docs-next button" href="/ghost-docs/docs/persistence"><span>Persistence: Store Your Program&#x27;s Data</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#providing-connection-technologies-to-ghost_connection-ghostconnectionfactory">Providing Connection Technologies to ghost_connection: ghost::ConnectionFactory</a><ul class="toc-headings"><li><a href="#feature-description">Feature Description</a></li><li><a href="#usage">Usage</a></li></ul></li><li><a href="#developing-a-new-connection-technology">Developing a New Connection Technology</a><ul class="toc-headings"><li><a href="#feature-description-1">Feature Description</a></li><li><a href="#usage-1">Usage</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/ghost-docs/" class="nav-home"><img src="/ghost-docs/img/ghost.svg" alt="Ghostmodule" width="66" height="58"/></a><div><h5>Docs</h5><a href="/ghost-docs/docs/en/setup">Getting Started</a><a href="/ghost-docs/docs/en/module">Guides</a><a href="/ghost-docs/docs/en/tutorial_helloworld">Tutorials</a></div><div><h5>Community</h5><a href="/ghost-docs/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/ghost-docs/blog">Blog</a><a href="https://github.com/mathieunassar">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/mathieunassar/ghostmodule/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/ghost-docs/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Mathieu Nassar</section></footer></div></body></html>